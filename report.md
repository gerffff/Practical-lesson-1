# Практична робота 1  

Пройдено обидві частини інтерактивного курсу «Git How To»

## Виконані завдання
## Частина 1.
Ознайомилися з основними командами Git: створення репозиторію, додавання файлів до індексу, створення комітів та перегляд історії. Також відпрацювали навички переміщення між комітами й відновлення стану файлів.

### 0. Підготовка
Завантажили архів з матеріалами курсу на комп'ютері з Windows та розпакували його. Створили дві основні папки: repositories для самостійної роботи та files з готовими прикладами на випадок помилок.

### 1. Фінальні приготування
Налаштували глобальні параметри Git для Windows. Встановили ім'я та адресу електронної пошти для ідентифікації автора комітів. Змінили стандартну назву початкової гілки з master на main. Налаштували коректну обробку кінцівок рядків для уникнення проблем між Windows та іншими системами.

### 2. Створення проєкту
У папці repositories створили нову папку work та у ній файл hello.html з текстом "Hello, World". В цій папці ініціалізували новий порожній репозиторій Git командою git init. Потім додали файл hello.html до індексу та створили перший коміт з повідомленням "Initial Commit".

### 3. Перевірка стану
Використали команду git status для перевірки стану репозиторію. Отримали підтвердження, що робоча директорія чиста (немає невідстежуваних або незбережених змін).

### 4. Внесення змін
Відредагували файл hello.html, додавши HTML-теги h1. Знову виконали git status, щоб переконатися, що Git виявив зміни у файлі, але вони ще не підготовлені до коміту.

### 5. Індексація змін
Виконали команду git add hello.html, щоб проіндексувати (підготувати) зміни файлу до наступного коміту. Команда git status підтвердила, що зміни тепер знаходяться в стадії готовності до фіксації.

### 6. Індексація та коміт
(Етап з теоретичним поясненням. Ніяких команд не виконувалося). Розглянули, що окремий крок індексації дозволяє гнучко групувати різні зміни файлів у незалежні логічні коміти.

### 7. Коміт змін
Створили новий коміт, що фіксує наші зміни з файлом hello.html. Для цього використали команду git commit без прапорця -m, що відкрило текстовий редактор (за замовчуванням Vim) для введення повідомлення коміту. Ввели повідомлення "Added h1 tag", зберегли та вийшли з редактора. Команда git status після цього показала, що робоча директорія знову чиста.

### 8. Зміни, а не файли
Внесли в файл hello.html дві незалежні зміни: спочатку додали стандартні теги <html> та <body>, проіндексували цю зміну. Потім, не комітячи, додали ще один етап — теги <head>. Команда git status почала показувати файл hello.html двічі: один раз як проіндексований для першої зміни, другий раз — як не проіндексований для другої. Закомітили лише першу зміну, а потім окремо додали в індекс та закомітили другу зміну. На практиці зрозуміли, що Git працює не з файлами в цілому, а з окремими змінами всередині них.

### 9. Історія проєкту
Використали команду git log для перегляду всієї історії комітів. Потім експериментували з форматуванням виводу: дивилися історію в один рядок , обмежували кількість комітів , фільтрували за часом та автором. Зберегли зручний формат виводу за допомогою глобальних налаштувань Git.

### 10. Отримання старих версій
Використали команду git checkout з хешем коміту, щоб «подорожувати в часі» та переглянути вміст файлу hello.html на момент першого коміту. Після цього опинилися в стані «відокремленого HEAD». Повернулися до останньої версії в гілці main за допомогою команди git switch main.

### 11. Створення тегів версій
Позначили важливі точки в історії зрозумілими іменами за допомогою тегів. Поточний стан позначили як v1. Переключилися на коміт перед v1 за допомогою запису v1^ та позначили його як v1-beta. Навчилися перемикатися між версіями за іменами тегів за допомогою git checkout. Переглянули список усіх тегів командою git tag.

### 12. Скасування локальних змін (до індексації)
Після внесення небажаних змін до файлу hello.html та перевірки статусу використали команду git restore hello.html. Ця команда повернула вміст файлу у робочій директорії до стану останнього коміту, скасувавши всі не проіндексовані зміни.

### 13. Скасування проіндексованих змін (перед комітом)
Внесли небажані зміни у файл та проіндексували їх командою git add. Для скасування індексації (видалення змін з області підготовки) використали команду git restore --staged hello.html. Після цього зміни все ще залишалися у файлі, тому для повного їх видалення виконали ще одну команду git restore hello.html.

### 14. Скасування комітів
Для скасування вже зробленого коміту використали безпечний підхід — команду git revert HEAD. Ця команда створила новий коміт, який протилежними діями відміняє зміни попереднього, залишаючи обидва коміти в історії. Це дозволяє уникати проблем при спільній роботі.

### 15. Видалення комітів з гілки (reset)
Використали потужну та небезпечну команду git reset --hard v1, щоб прибрати останні два коміти з історії гілки main та одночасно повернути робочу директорію до стану коміту v1. Попередньо створили тег oops, щоб не втратити посилання на видалені коміти. Переконалися, що самі коміти не зникають з репозиторію одразу, але без тегу на них було б важко посилатися.

### 16. Видалення тегу oops
Видалили тимчасовий тег oops командою git tag -d oops, після чого «помилкові» коміти перестали відображатися в лозі, оскільки на них не залишилося жодних посилань.

### 17. Внесення змін до комітів
Скористалися командою git commit --amend, щоб змінити щойно зроблений коміт: додали до нього пропущену зміну (email у коментар) та оновили повідомлення коміту. Це перезаписало попередній коміт, не створюючи нового.

### 18. Створення гілки
Створили нову гілку під назвою style для розробки нової функції (CSS-стилів) командою git switch -c style. У цій гілці створили файл style.css, закомітили його, а потім змінили hello.html, щоб підключити стилі, і закомітили цю зміну.

### 19. Перемикання гілок
Навчилися перемикатися між гілками за допомогою git switch. Переключилися з гілки style на main і переконалися, що зміни, зроблені в style (файл CSS та посилання на нього), у гілці main відсутні. Потім повернулися назад до гілки style.

### 20. Переміщення файлів
Використали команду git log hello.html для перегляду історії змін конкретного файлу. Потім перейменували файл hello.html на index.html за допомогою стандартної команди mv. Git спочатку інтерпретував це як видалення одного файлу та створення нового, але після виконання git add . сам визнав операцію як перейменування. Для безпечного переміщення файлу style.css у підпапку css використали команду git mv. Після коміту змін навчилися переглядати повну історію переміщеного файлу за допомогою git log --follow.

### 21. Зміни в гілці main
Переключилися з гілки style на гілку main. Створили новий файл README з описом проєкту та закомітили його в гілку main. Таким чином, у гілці main з'явився новий коміт, якого поки що немає в гілці style.

### 22. Перегляд розбіжних гілок
Використали команду git log --all --graph для наочного перегляду всіх гілок у вигляді графа. На графіку побачили, що гілки main та style розійшлися після спільного коміту «Added copyright statement with email», і кожна має свої унікальні коміти.

### 23. Злиття
Переключилися на гілку style та виконали команду git merge main, щоб злити зміни з гілки main (новий файл README) в поточну гілку style. Після злиття історія стала нелінійною, з'явився новий коміт злиття, який об'єднує дві лінії розробки.

### 24. Створення конфлікту
Перейшли назад у гілку main та внесли зміни у файл hello.html, додавши тег <title>. Закомітили ці зміни. Таким чином, у гілці main та в гілці style тепер є різні, але типові для однієї частини файлу, зміни.

### 25. Вирішення конфліктів
Перейшли в гілку style та спробували знову виконати git merge main. Git повідомив про конфлікт автоматичного злиття у файлі index.html (який у гілці style був перейменований з hello.html). Відкрили файл та побачили маркери конфлікту (<<<<<<<, =======, >>>>>>>), що показують суперечливі зміни з обох гілок. Спочатку скасували злиття командою git merge --abort, потім знову запустили злиття, вручну відредагували файл, об'єднавши потрібні зміни з обох гілок. Після цього додали виправлений файл та закомітили результат злиття.

### 26. rebase проти merge
Розпочали підготовку до порівняння двох методів об'єднання гілок: merge (злиття зі створенням окремого коміту) та rebase (перебазування, яке робить історію лінійною).

### 27. Відкочування гілки style
Щоб порівняти merge та rebase, спочатку повернули гілку style до стану, який був до першого злиття. Для цього використали команду git reset --hard HEAD~2, яка перемістила покажчик гілки на два коміти назад, безповоротно відкинувши коміт злиття та коміт вирішення конфлікту.

### 28. Перебазування
Перебуваючи в гілці style, виконали команду git rebase main. В процесі перебазування виник конфлікт, оскільки Git почав застосовувати коміти з style поверх актуального стану main. Конфлікт виник у файлі hello.html (бо в main файл ще не був перейменований). Вирішили конфлікт, відредагувавши файл. Потім, на відміну від злиття, не створювали нового коміту, а виконали git add . та git rebase --continue, щоб продовжити процес перебазування. В результаті отримали лінійну історію, де всі коміти з style розташувалися після комітів з main.

### 29. Злиття в гілку main
Перейшли в гілку main та виконали git merge style. Оскільки після перебазування гілка style прямо випереджала main, Git зміг виконати «швидке перемотування» (fast-forward), просто пересунувши покажчик main на той самий коміт, що й style. Коміт злиття не створювався.

## Частина 2.
Навчилися працювати з гілками: створювати нові гілки, перемикатися між ними та об’єднувати зміни. Додатково розглянули конфлікти під час злиття і способи їх вирішення.

### 30. Клонування репозиторіїв
Вийшли з директорії work на рівень вище (cd ..) та створили копію (клон) репозиторію за допомогою команди git clone work home. У результаті отримали два незалежних репозиторії: оригінальний work та клонований home.

### 31. Перегляд клонованого репозиторію
Перейшли в клонований репозиторій home. Переконалися, що він містить усі файли та повну історію комітів оригіналу. Також помітили віддалені гілки з префіксом origin/ (наприклад, origin/main, origin/style).

### 32. Що таке origin?
Команда git remote показала, що клонований репозиторій має віддалене джерело під іменем origin. Команда git remote show origin вивела детальну інформацію: це шлях до оригінального репозиторію work на диску.

### 33. Віддалені гілки
Команда git branch показала лише локальну гілку main. Команда git branch -a показала всі гілки, включаючи віддалені.

### 34. Зміна оригінального репозиторію
Перейшли в оригінальний репозиторій work, змінили та закомітили файл README. Тепер у work є новіший коміт, якого немає в клоні home.

### 35. Підтягування змін
У клонованому репозиторії home виконали git fetch. Ця команда завантажила нові коміти з origin (репозиторію work), але не змінила жодні локальні гілки. Перевірка файлу README підтвердила, що локальна версія залишилася старою.

### 36. Злиття підтягнутих змін
Виконали git merge origin/main, щоб злити завантажені зміни з віддаленої гілки origin/main у локальну гілку main. Після цього зміни у файлі README з'явилися локально.

### 37. Додавання гілки відстеження
Створили локальну гілку style, яка автоматично відстежує віддалену гілку origin/style, командою git branch --track style origin/style. Тепер команда git branch -a показує її серед локальних гілок.

### 38. Чисті репозиторії
Створили «чистий» (bare) репозиторій, призначений лише для обміну даними, командою git clone --bare work work.git. Цей репозиторій не має робочих файлів, тільки внутрішні дані Git.

### 39. Додавання віддаленого репозиторія
У оригінальному репозиторії work додали нове віддалене джерело під іменем shared, яке вказує на створений чистий репозиторій (git remote add shared ../work.git).

### 40. Відправка змін
У репозиторії work змінили файл README та закомітили зміни. Потім відправили ці зміни у спільний чистий репозиторій командою git push shared main.

### 41. Підтягування спільних змін
У клонованому репозиторії home також додали віддалене джерело shared та створили локальну гілку, що відстежує його. Виконали git pull shared main, щоб одночасно отримати зміни з shared та злити їх у поточну гілку. Зміни у файлі README успішно підтягнулися.

### 42. Розміщення ваших Git репозиторіїв
Розглянули можливість запуску простого Git-сервера за допомогою вбудованої утиліти git daemon для обміну репозиторіями через мережу.


